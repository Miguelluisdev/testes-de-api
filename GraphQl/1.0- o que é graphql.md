# 🧪 Qualidade e Testes em APIs GraphQL (Visão QA)

## 1. Entendendo o GraphQL

Antes de mergulhar nos detalhes de QA, é fundamental entender os conceitos básicos do **GraphQL**.

### 🧭 O que é GraphQL?

**GraphQL** é uma **linguagem de consulta e manipulação de dados para APIs**, além de ser um **runtime** que executa essas consultas com base em seus dados existentes.  
Pense nele como uma **evolução ou alternativa ao REST**.

### 🌟 Vantagens Principais

- **Over-fetching / Under-fetching:**  
  Diferente do REST, o cliente solicita **exatamente os dados que precisa** — nem mais, nem menos.

- **Um único endpoint:**  
  Enquanto REST pode ter vários endpoints (`/users`, `/products`, etc.), o GraphQL geralmente usa **um único endpoint** (exemplo: `/graphql`).

- **Tipagem Forte:**  
  Todo o GraphQL é baseado em um **sistema de tipos rígido**, que melhora a **validação**, **documentação** e **segurança**.

### ⚙️ Componentes Chave

| Componente | Função |
|-------------|--------|
| **Schema** | Define todos os tipos e operações disponíveis na API. É o coração do GraphQL. |
| **Queries** | Usadas para **buscar** dados. |
| **Mutations** | Usadas para **modificar** dados (criar, atualizar, excluir). |
| **Subscriptions** | Usadas para receber **atualizações em tempo real** (ex: chat, notificações). |
| **Resolvers** | Funções que **resolvem** os campos do schema e retornam os dados solicitados. |

---

### 🔄 Comparativo Visual: REST x GraphQL

| Aspecto | REST | GraphQL |
|----------|------|----------|
| **Número de Endpoints** | Vários (`/users`, `/posts`, `/comments`) | Um único endpoint (`/graphql`) |
| **Controle de Dados Retornados** | Limitado (cada endpoint define o retorno) | Total — o cliente escolhe os campos desejados |
| **Over-fetching / Under-fetching** | Comum | Evitado |
| **Tipagem Forte** | Não nativo | Integrado |
| **Documentação Automática** | Manual | Gerada automaticamente pelo schema |
| **Real-time (Subscriptions)** | Necessita WebSocket separado | Nativo via `subscriptions` |

---

## 2. Segurança em GraphQL (Visão QA)

Como QA, a segurança é um ponto crítico. O GraphQL, por ser altamente flexível, traz algumas preocupações específicas que devem ser validadas durante os testes.

### 🔒 Validação de Entrada
- **Tipagem Forte:** O sistema de tipos do GraphQL ajuda a garantir que os dados estejam no formato correto.  
  ➤ Teste com **dados inválidos** e **formatos incorretos** para validar o tratamento de erros.  
- **Argumentos Obrigatórios/Opcionais:**  
  ➤ Verifique se campos obrigatórios realmente são exigidos e se os opcionais têm comportamento adequado.

### 🔐 Autorização e Autenticação
- **Autenticação:**  
  ➤ Teste chamadas **sem autenticação** ou com **tokens inválidos** e verifique se o acesso é negado.  
- **Autorização por Campo/Tipo:**  
  ➤ Valide que diferentes perfis de usuário (ex: admin, user) só acessam os campos permitidos.  
  ➤ Tente acessar campos sensíveis (ex: `salary`, `email`, `role`) com um usuário comum.  
- **Negação de Acesso (Negative Testing):**  
  ➤ Tente acessar recursos sem permissão para confirmar a robustez das restrições de acesso.

### ⚔️ Proteção contra Ataques
- **Depth Limiting (Limitação de Profundidade):**  
  ➤ Teste queries com **muitas camadas aninhadas** e verifique se o servidor limita a profundidade da query.  
- **Query Cost Analysis:**  
  ➤ Avalie como o sistema lida com **queries muito complexas ou caras** computacionalmente.  
- **Rate Limiting:**  
  ➤ Teste o limite de requisições simultâneas e observe se a API bloqueia excessos.  
- **DDoS:**  
  ➤ Simule alto volume de requisições para medir a resiliência do servidor.  
- **Exposição de Dados Sensíveis:**  
  ➤ Verifique se o schema não expõe campos que **não deveriam ser públicos**.

---

## 3. Performance em GraphQL (Visão QA)

A flexibilidade do GraphQL pode impactar a performance. O QA deve garantir que queries complexas não degradem o sistema.

### ⚙️ Problema N+1
- Ocorre quando uma query solicita uma lista e, para cada item, faz uma nova requisição ao banco.  
- **Como testar:**  
  ➤ Crie queries grandes e monitore **tempo de resposta** e **número de requisições**.  
  ➤ Ferramentas como **DataLoader** ajudam a mitigar o problema.

### 🧩 Queries Complexas
- **Profundidade:** Queries muito profundas podem causar lentidão.  
- **Campos Computados:** Campos que exigem cálculos complexos podem ser gargalos.  
- **Testes de Carga:**  
  ➤ Use ferramentas de stress test para validar performance em queries complexas.

### ⚡ Cache
- **Client-Side Caching:** Bibliotecas como Apollo Client e Relay usam cache local.  
- **Server-Side Caching:** Teste a diferença de resposta **com e sem cache no servidor**.  
- **Monitoramento:**  
  ➤ Valide métricas de performance, tempo de execução e erros dos resolvers.

---

## 4. Dados em GraphQL (Visão QA)

A integridade e consistência dos dados são essenciais em qualquer API GraphQL.

### 🧱 Validação de Schema
- **Tipos e Campos:** Confirme que o schema reflete os dados reais retornados.  
- **NonNull (!):** Campos `NonNull` nunca devem retornar `null`.  
  ➤ Teste situações onde o backend pode retornar `null` para esses campos.  
- **Enums:** Teste valores **válidos e inválidos**.

### 🔁 Consistência dos Dados
- **Mutations:**  
  ➤ Após executar mutations, verifique se as queries retornam dados atualizados.  
- **Relacionamentos:**  
  ➤ Confirme se os relacionamentos entre entidades são consistentes (ex: `User → Posts`).

### 📄 Paginação e Filtros
- Teste paginação (`first`, `after`, `last`, `before`) e garanta que os **cursores e limites estão corretos**.  
- Valide filtros e ordenações com diferentes parâmetros.

### ⚠️ Tratamento de Erros
- **Mensagens Claras:** As mensagens devem ser informativas, mas **sem expor detalhes internos**.  
- **Códigos de Erro:**  
  ➤ Garanta que os códigos corretos são retornados para cada tipo de falha.

---

## 5. Ferramentas para QA em GraphQL

| Categoria | Ferramenta | Finalidade |
|------------|-------------|------------|
| IDE Interativa | **GraphiQL / GraphQL Playground** | Explorar schema, testar queries e mutations |
| Testes de API | **Postman / Insomnia** | Enviar requisições GraphQL e validar respostas |
| DevTools | **Apollo Client DevTools** | Inspecionar cache, queries e mutations no front-end |
| Testes de Carga | **K6 / JMeter / Artillery** | Simular alto volume de requisições |
| Mock de Dados | **GraphQL Faker** | Gerar dados fake com base no schema |
| Unitários / Integração | **Jest / Mocha** | Testar resolvers e lógica de negócio |
| E2E | **Cypress / Playwright / Selenium** | Validar fluxo completo com a API GraphQL |

---

## 💡 Dicas Adicionais para QA em GraphQL

- **Entenda o Schema:** É o contrato entre o cliente e o servidor — dedique tempo para estudá-lo.  
- **Colaboração:** Trabalhe junto aos devs para entender resolvers e regras de negócio.  
- **Documentação:** Use a documentação gerada automaticamente pelo schema no Playground.  
- **Monitoramento:** Exija logs e métricas de execução dos resolvers para identificar gargalos e falhas em produção.

---

### ✅ Conclusão

Ao focar nesses pontos — **segurança, performance, integridade de dados e ferramentas adequadas** — o QA garante que a API GraphQL não só funcione corretamente, mas também seja **segura, eficiente e confiável**.

> “Garantir qualidade em GraphQL não é só testar o que se vê, mas também proteger o que não se deve ver.”
