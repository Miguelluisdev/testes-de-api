# ğŸ§  AnotaÃ§Ãµes Importantes sobre GraphQL 

Essas anotaÃ§Ãµes resumem os principais conceitos e responsabilidades do QA ao trabalhar com **APIs GraphQL** â€” com foco em **seguranÃ§a**, **performance**, **validaÃ§Ã£o de dados** e **contrato de schema**.

---

## 1. GraphQL â‰  Banco de Dados

- GraphQL Ã© uma **linguagem de consulta para APIs** e um **runtime** de execuÃ§Ã£o.  
- Ele **nÃ£o Ã© um banco de dados** â€” funciona como uma **camada entre o cliente e as fontes de dados** (banco, microserviÃ§os, APIs REST, etc.).

ğŸ” **ImplicaÃ§Ã£o QA:**  
O QA deve compreender que o GraphQL apenas **organiza o acesso aos dados**, e nÃ£o os armazena. Logo, os testes devem focar na **consistÃªncia e integridade da camada de integraÃ§Ã£o**, e nÃ£o apenas nos dados em si.

---

## 2. Single Endpoint

- Normalmente hÃ¡ **um Ãºnico endpoint** (exemplo: `/graphql`), diferente do REST que possui mÃºltiplos.  
- Todas as operaÃ§Ãµes â€” **queries**, **mutations** e **subscriptions** â€” passam por ele.

ğŸ” **ImplicaÃ§Ã£o QA:**  
O foco de **seguranÃ§a, autenticaÃ§Ã£o e performance** estÃ¡ concentrado nesse Ãºnico ponto de entrada.  
Testes de **rate limiting** e **acesso indevido** sÃ£o essenciais.

---

## 3. Sistema de Tipos Fortes (Schema)

- O **schema** Ã© o **coraÃ§Ã£o do GraphQL**.  
  Ele define todos os tipos de dados e operaÃ§Ãµes disponÃ­veis.  
- Tipos especiais:
  - `Query`: leitura de dados.
  - `Mutation`: modificaÃ§Ã£o de dados.
  - `Subscription`: dados em tempo real.
- `!` (**NonNull**): indica que um campo **nunca pode ser nulo**.

ğŸ§© **ImplicaÃ§Ãµes para QA:**
- Testar se campos `NonNull` realmente **nÃ£o retornam `null`**.
- Validar se os **erros sÃ£o tratados corretamente** quando isso ocorre.
- O schema Ã© o **contrato da API** â€” qualquer tipo ou valor fora do esperado Ã© **bug**.
- A documentaÃ§Ã£o Ã© **gerada automaticamente** a partir do schema, sendo uma excelente referÃªncia para testes.

---

## 4. Queries (Leitura de Dados)

- Permitem que o cliente solicite **exatamente os dados necessÃ¡rios**.  
- Evita **over-fetching** (dados demais) e **under-fetching** (dados de menos).

ğŸ§ª **ImplicaÃ§Ã£o QA:**  
- Testar se a query retorna apenas os campos solicitados.  
- Remover campos e verificar se realmente nÃ£o aparecem na resposta.  
- Validar tempo de resposta e estrutura dos dados.

---

## 5. Mutations (ModificaÃ§Ã£o de Dados)

- Usadas para **criar, atualizar ou deletar** informaÃ§Ãµes.  
- Sempre retornam o **estado atualizado** do objeto modificado.

ğŸ§ª **ImplicaÃ§Ã£o QA:**  
- Testar se os dados sÃ£o **persistidos corretamente** apÃ³s a mutation.  
- Validar se as queries subsequentes refletem as mudanÃ§as.  
- Assegurar **idempotÃªncia** onde aplicÃ¡vel.

---

## 6. Subscriptions (Dados em Tempo Real)

- Permitem que o cliente receba **atualizaÃ§Ãµes em tempo real** via WebSocket.  
  Exemplo: notificaÃ§Ãµes, chats, dashboards dinÃ¢micos.

ğŸ§ª **ImplicaÃ§Ã£o QA:**  
- Testar **latÃªncia** e **consistÃªncia** das mensagens.  
- Verificar **assinaturas mÃºltiplas** e **cancelamentos** de subscription.  
- Simular desconexÃµes e reconexÃµes do cliente.

---

## 7. Resolvers

- SÃ£o **funÃ§Ãµes backend** que resolvem os campos definidos no schema.  
- Cada campo em GraphQL Ã© processado por um resolver.

âš™ï¸ **ImplicaÃ§Ã£o QA:**  
- Resolvers sÃ£o pontos crÃ­ticos para **seguranÃ§a** e **performance**.  
- Testar se estÃ£o **respeitando regras de acesso** e **autorizaÃ§Ã£o**.  
- O **problema N+1** costuma surgir aqui â€” o uso de **DataLoader** Ã© uma boa prÃ¡tica para evitar isso.

---

## 8. SeguranÃ§a (Pontos CrÃ­ticos para QA)

- **AutorizaÃ§Ã£o por Campo/Tipo:**  
  Diferentes perfis de usuÃ¡rio devem acessar apenas os dados permitidos.
- **Depth Limiting:**  
  Previne ataques de queries aninhadas infinitas.  
  â¤ Teste queries muito profundas.
- **Query Cost Analysis:**  
  Avalia o custo computacional de queries antes da execuÃ§Ã£o.  
  â¤ Teste queries complexas e observe se sÃ£o bloqueadas ou lentas.
- **Rate Limiting:**  
  Protege contra abusos e ataques de forÃ§a bruta.  
- **ExposiÃ§Ã£o de Dados SensÃ­veis:**  
  Garanta que o schema nÃ£o exponha informaÃ§Ãµes confidenciais.

ğŸ” **ImplicaÃ§Ã£o QA:**  
Esses testes ajudam a garantir que o GraphQL **nÃ£o se torne um ponto Ãºnico de falha ou vazamento de dados**.

---

## 9. Performance (Pontos CrÃ­ticos para QA)

- **Problema N+1:**  
  Um dos maiores gargalos de performance em GraphQL.  
  â¤ QA deve identificar queries que disparam mÃºltiplas consultas ao banco.  
  â¤ Verificar o uso de **DataLoader** ou cache.
- **Queries Complexas/Lentas:**  
  â¤ Realizar **testes de carga e stress**.  
- **Cache:**  
  Avaliar **cache do cliente (Apollo, Relay)** e **do servidor**.  
- **Monitoramento:**  
  IndispensÃ¡vel para observar **tempo de execuÃ§Ã£o dos resolvers** em produÃ§Ã£o.

---

## 10. Tratamento de Erros

- Em GraphQL, os erros sÃ£o retornados no campo `"errors"` da resposta.  
- Mesmo assim, o **HTTP status pode ser 200 OK**.

ğŸ§ª **ImplicaÃ§Ã£o QA:**  
- Verificar o conteÃºdo do campo `"errors"`.  
- As mensagens devem ser **claras**, mas **sem expor informaÃ§Ãµes internas** (stack trace, SQL, etc.).  
- Testar casos de falha em autenticaÃ§Ã£o, autorizaÃ§Ã£o e validaÃ§Ã£o de dados.

---

## 11. Ferramentas Essenciais para QA

| Categoria | Ferramenta | Finalidade |
|------------|-------------|------------|
| **IDE Interativa** | GraphiQL / GraphQL Playground | Explorar schema, queries e mutations |
| **Testes de API** | Postman / Insomnia | AutomaÃ§Ã£o de requisiÃ§Ãµes GraphQL |
| **DevTools** | Apollo Client DevTools | Depurar queries, cache e mutations |
| **Testes de Carga** | K6 / JMeter / Artillery | Testar performance sob alto volume |

---

## ğŸ§© ConclusÃ£o para QA

A flexibilidade do GraphQL Ã© uma **faca de dois gumes**:  
Ã‰ **poderosa** para o cliente, mas exige **maior vigilÃ¢ncia em seguranÃ§a e performance** do servidor.

ğŸ¯ **O QA deve focar em:**
- Validar o **contrato do schema** e sua tipagem.  
- Garantir **autorizaÃ§Ã£o correta** e **limitaÃ§Ã£o de profundidade**.  
- Monitorar **performance dos resolvers**.  
- Trabalhar junto com os devs para entender **lÃ³gica de negÃ³cio e resoluÃ§Ãµes de dados**.

> â€œConhecer o schema Ã© conhecer a alma da API.  
> O QA que entende o schema testa com propÃ³sito e garante qualidade de ponta a ponta.â€
